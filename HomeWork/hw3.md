NDArray 类的设计理念是，所有处理数组结构的逻辑都应该在 Python 中编写。只有真正执行原始底层操作的低级代码（例如在 C++ 中编写的代码，包括进行 CUDA 调用等），以及管理这些底层操作的代码（因为它们可能需要在 GPU 上分配内存），才会被写成 C++。这种分离的精确性在你完成任务时可能会变得更加清晰，但一般来说，所有可以在 Python 中完成的工作都会在 Python 中完成；通常会牺牲一些效率，例如我们经常会大量使用 `.compact()` 来简化底层 C++ 实现，尽管这会复制内存。

更详细地说，NDArray 类中有五个字段你需要熟悉（请注意，这些字段的真实类成员都以下划线开头，例如，_handle、_strides 等，其中一些字段会暴露为公共属性... 对于你的所有代码来说，使用内部的带下划线的版本是可以的）。

设备 - 一种 BackendDevice 类型的对象，它是一个简单的包装器，包含了对底层设备后端（例如 CPU 或 CUDA）的链接。

句柄 - 一个类对象，用于存储数组的底层内存。这是作为 device.Array() 类的一种类的分配方式，尽管所有这些分配都是在提供的代码中完成的（具体来说是 NDArray.make 函数），你不需要担心自己调用它。

形状 - 一个元组，指定数组中每个维度的大小。

步长 - 一个元组，指定数组中每个维度的步长。

偏移量 - 一个整数，指示数组实际上从底层 device.Array 内存的哪个位置开始（存储这个值是方便我们更容易地管理指向现有内存，而不必跟踪分配）。

通过操纵这些字段，即使是纯 Python 代码也可以执行数组上许多所需的操作，比如排列维度（即转置）、广播等。然后对于原始数组操作调用，设备类有许多方法（在 C++ 中实现），其中包含了必要的实现。

有几点需要注意：

在内部，该类可以使用任何有效的数据数组操作方式作为"设备"后端。甚至，例如，一个 numpy 数组，但是我们不是实际上使用 numpy.ndarray 来表示 n 维数组，而是在 numpy 中表示一个"扁平"的一维数组，然后调用相关的 numpy 方法来实现对这个原始内存的所有所需操作。这正是我们在 ndarray_backend_numpy.py 文件中所做的，它基本上提供了一个 "存根引用"，只是在所有方面都使用 numpy。你可以使用这个类来帮助你更好地调试你自己的用于 "本机" CPU 和 GPU 后端的 "真实" 实现。 对于你的许多 Python 实现，特别重要的一点将是 NDArray.make 调用。



为了了解为什么这些都属于同一类别，让我们考虑一下Compact()函数的实现。回想一下，如果矩阵在内存中以"行主"形式顺序排列（但实际上是对高维数组的一般化），那么它被认为是紧凑的，即最后一个维度先排列，然后是倒数第二个维度，依此类推，一直到第一个维度。在我们的实现中，我们还要求分配的后端数组的总大小等于数组的大小（即，底层数组的数据也不能在数组数据之前或之后，这意味着 .offset 字段等于零）。

现在让我们考虑使用3D数组作为示例的情况，说明紧凑调用可能是如何工作的。这里的形状和步幅是被紧凑化的矩阵的形状和步幅（即，在我们对其进行压缩之前）。

换句话说，我们正在从基于步幅的矩阵表示转换为纯粹的顺序表示。

现在，实现Compact()的挑战在于你希望该方法适用于任何数量的输入维度。针对不同固定维度大小的数组进行专门化很容易，但对于通用实现，你需要考虑如何执行同样的操作，你实际上需要一个"可变数量的for循环"。一个提示是，一种方法是保持一个索引向量（大小等于维度数量），然后在循环中手动递增它们（包括在任何达到其最大大小时进行"进位"操作）。

然而，如果你在这方面真的遇到了困难，你可以利用这样一个事实，即我们可能不会要求你处理超过6个维度的矩阵（尽管我们会使用6个维度，例如我们在课堂上讨论的im2col操作）。

与setitem的联系
虽然setitem功能看似非常不同，但实际上与Compact()密切相关。\__setitem__()是在设置对象的某些元素时调用的Python函数，即，

```
A[::2,4:5,9] = 0 # or = some_other_array
```

